<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     YHang-tech&#39;s Personal Blog
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/main.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">YHang-tech&#39;s Personal Blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-Java反射机制" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/21/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"
    >Java反射机制</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/21/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-03-21T15:54:44.000Z" itemprop="datePublished">2020-03-21</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="一、反射是什么"><a href="#一、反射是什么" class="headerlink" title="一、反射是什么"></a>一、反射是什么</h2><p>反射技术可以对一个类进行解剖。</p>
<p>反射是Java特征之一，是一种间接操作目标对象的机制。</p>
<p>机制：运行时动态加载，可获取任意一个类的所有属性和方法，调用方法，访问属性。程序中对象的类型一般都是在编译期就确定下来的，而当我们的程序在运行时，可能需要动态的加载一些类，这些类因为之前用不到，所以没有加载到jvm，这时，使用Java反射机制可以在运行期动态的创建对象并调用其属性，它是在运行时根据需要才加载。</p>
<p>特性：动态</p>
<h2 id="二、反射原理"><a href="#二、反射原理" class="headerlink" title="二、反射原理"></a>二、反射原理</h2><p>Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p>
<p>Class 对象是在反射中会使用到的一类系统定义的类实例。</p>
<p><img src="/2020/03/21/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/2020-03-22-a.png" alt></p>
<p>上图中，Student 类产生了两个实例，但只会有一个Student类 对应的Class 对象。</p>
<p>而Teacher 类有一个Teacher类对应的Class 对象。</p>
<h2 id="三、反射用途"><a href="#三、反射用途" class="headerlink" title="三、反射用途"></a>三、反射用途</h2><p>1、反编译：.class–&gt;.java</p>
<p>2、通过反射机制访问java对象的属性，方法，构造方法等</p>
<p>3、当我们在使用IDE,比如Ecplise时，<u>当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射</u>。</p>
<p>4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。</p>
<h2 id="四、使用反射需import"><a href="#四、使用反射需import" class="headerlink" title="四、使用反射需import"></a>四、使用反射需import</h2><p>Java.lang.Class;</p>
<p>Java.lang.reflect.Constructor;</p>
<p>Java.lang.reflect.Field;</p>
<p>Java.lang.reflect.Method;</p>
<p>Java.lang.reflect.Modifier;</p>
<h2 id="五、反射的基本使用："><a href="#五、反射的基本使用：" class="headerlink" title="五、反射的基本使用："></a>五、反射的基本使用：</h2><h4 id="1、获得Class：主要有三种方法："><a href="#1、获得Class：主要有三种方法：" class="headerlink" title="1、获得Class：主要有三种方法："></a><strong>1、获得Class：主要有三种方法：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fanshe</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//第一种方式获取Class对象  </span></span><br><span class="line">		Student stu1 = <span class="keyword">new</span> Student();<span class="comment">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class="line">		Class stuClass = stu1.getClass();<span class="comment">//（1）Object--&gt;getClass，获取Class对象</span></span><br><span class="line">		System.out.println(stuClass.getName());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第二种方式获取Class对象</span></span><br><span class="line">		Class stuClass2 = Student<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//（2）任何数据类型（包括基本的数据类型）都有一个“静态”的class属性</span></span><br><span class="line">		System.out.println(stuClass == stuClass2);<span class="comment">//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第三种方式获取Class对象</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class stuClass3 = Class.forName(<span class="string">"fanshe.Student"</span>);<span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line">            <span class="comment">//（3）通过class类的静态方法：forName(String className)（最常用）</span></span><br><span class="line">			System.out.println(stuClass3 == stuClass2);<span class="comment">//判断三种方式是否获取的是同一个Class对象</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在运行期间，一个类，只有一个Class对象产生，所以打印结果都是true；</p>
<p>三种方式中，常用第三种，第一种对象都有了还要反射干什么，第二种需要导入类包，依赖太强，不导包就抛编译错误。一般都使用第三种，一个字符串可以传入也可以写在配置文件中等多种方法。</p>
<h4 id="2、判断是否为某个类的示例："><a href="#2、判断是否为某个类的示例：" class="headerlink" title="2、判断是否为某个类的示例："></a><strong>2、判断是否为某个类的示例：</strong></h4><p>一般的，我们使用instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断时候为某个类的实例，他是一个native方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3、创建实例：通过反射来生成对象主要有两种方法："><a href="#3、创建实例：通过反射来生成对象主要有两种方法：" class="headerlink" title="3、创建实例：通过反射来生成对象主要有两种方法："></a><strong>3、创建实例：通过反射来生成对象主要有两种方法：</strong></h4><p>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure>

<p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，<u>这种方法可以用指定的构造器构造类的实例。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String的Class对象</span></span><br><span class="line">Class&lt;?&gt; str = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//通过Class对象获取指定的Constructor构造器对象</span></span><br><span class="line">Constructor constructor=c.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//根据构造器创建实例：</span></span><br><span class="line">Object obj = constructor.newInstance(“hello reflection”);</span><br></pre></td></tr></table></figure>

<h4 id="4-获取构造方法、成员变量、成员函数并调用："><a href="#4-获取构造方法、成员变量、成员函数并调用：" class="headerlink" title="4.获取构造方法、成员变量、成员函数并调用："></a>4.获取构造方法、成员变量、成员函数并调用：</h4><h5 id="1-批量获取所得的“公有的”方法："><a href="#1-批量获取所得的“公有的”方法：" class="headerlink" title="1.批量获取所得的“公有的”方法："></a>1.批量获取所得的“公有的”方法：</h5><p>public Constructor[] getConstructors()</p>
<p>public Field[] getFields()</p>
<p>public Method[] getMethods()</p>
<h5 id="2-批量获得所得的方法（包括：私有、受保护、默认、公有）"><a href="#2-批量获得所得的方法（包括：私有、受保护、默认、公有）" class="headerlink" title="2.批量获得所得的方法（包括：私有、受保护、默认、公有）"></a>2.批量获得所得的方法（包括：私有、受保护、默认、公有）</h5><p>public Constructor[] getDeclaredConstructors()</p>
<p>public Field[] getDeclaredFields()</p>
<p>public Method[] getDeclaredMethods()</p>
<h5 id="3-获取单个“公有的”方法"><a href="#3-获取单个“公有的”方法" class="headerlink" title="3.获取单个“公有的”方法"></a>3.获取单个“公有的”方法</h5><p>public Constructor getConstructor(Class… parameterTypes)：括号内为类型（class对象），如：char.class,null</p>
<p>public Field getField(String fieldName)：括号内为属性名称</p>
<p>public Method getMethod(String name,Class&lt;?&gt;… parameterTypes)：括号内为方法名，形参的类型（class对象）</p>
<h5 id="4-获取所有单个方法（包括私有的，不包括继承的"><a href="#4-获取所有单个方法（包括私有的，不包括继承的" class="headerlink" title="4.获取所有单个方法（包括私有的，不包括继承的)"></a>4.获取所有单个方法（包括私有的，不包括继承的)</h5><p>public Constructor getDeclaredConstructor(Class… parameterTypes)</p>
<p>public Field getDeclaredField(String fieldName)</p>
<p>public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes) </p>
<h5 id="5-调用"><a href="#5-调用" class="headerlink" title="5.调用"></a>5.调用</h5><p>Constructor–&gt;newInstance(Object… initargs) 参数为：构造方法对应的参数</p>
<p>Field –&gt; public void set(Object obj,Object value) 参数为：要设置的字段所在的对象；要为字段设置的值</p>
<p>Method –&gt; public Object invoke(Object obj,Object… args) 参数为：要调用方法的对象；调用方式时所传递的实参</p>
<h5 id="6、反射main方法"><a href="#6、反射main方法" class="headerlink" title="6、反射main方法"></a>6、反射main方法</h5><p><strong>7、利用发射创建数值</strong></p>
<h5 id="8-反射方法的其他使用–通过反射运行配置文件内容"><a href="#8-反射方法的其他使用–通过反射运行配置文件内容" class="headerlink" title="8.反射方法的其他使用–通过反射运行配置文件内容"></a>8.反射方法的其他使用–通过反射运行配置文件内容</h5><p><strong>9、反射方法的其他使用–通过反射越过泛型检查</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">https://blog.csdn.net/sinat_38259539/article/details/71799078</a></p>
<p><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">https://www.sczyh30.com/posts/Java/java-reflection-1/</a></p>
<p><a href="https://blog.csdn.net/liujiahan629629/article/details/18013523" target="_blank" rel="noopener">https://blog.csdn.net/liujiahan629629/article/details/18013523</a></p>
<p>直接摘录自：<a href="https://blog.csdn.net/a745233700/article/details/82893076" target="_blank" rel="noopener">https://blog.csdn.net/a745233700/article/details/82893076</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/reflect-Java-basic/" rel="tag">reflect;Java;basic</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-java注解" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/18/java%E6%B3%A8%E8%A7%A3/"
    >java注解</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/18/java%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-18T03:50:50.000Z" itemprop="datePublished">2020-03-18</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="注解Annotation-用法-："><a href="#注解Annotation-用法-：" class="headerlink" title="注解Annotation 用法 ："></a>注解Annotation 用法 ：</h2><p>注解又称Java 标注，是一种注释机制</p>
<p>java中，类、方法、变量、参数、包都可以被标注，java可以通过反射获得标注内容。</p>
<p>java 可以在运行时获得标注内容</p>
<p>Java自定义了7个注解</p>
<p>在代码中作用的注解：</p>
<p>@Override 检查该方法是否被重写，在父类或接口中未发现该方法，编译报错</p>
<p>@Deprecated 标记过时方法，若使用该方法，编译报错</p>
<p>@SuppressWarnings 指示编译器去忽略注解中声明的警告</p>
<p>作用在其他注解中的注解（元注解）：</p>
<p>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</p>
<p>@Documented - 标记这些注解是否包含在用户文档中。</p>
<p>@Target - 标记这个注解应该是哪种 Java 成员。</p>
<p>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</p>
<h3 id="Annotation-通用定义"><a href="#Annotation-通用定义" class="headerlink" title="Annotation 通用定义"></a>Annotation 通用定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation1 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。定义了 MyAnnotation1 之后，我们可以在代码中通过 “@MyAnnotation1” 来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。下面分别说说它们的含义：</p>
<p><strong>(01) @interface</strong></p>
<p>使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。</p>
<p>定义 Annotation 时，@interface 是必须的。</p>
<p>注意：它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。</p>
<p><strong>(02) @Documented</strong></p>
<p>类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。</p>
<p>定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。</p>
<p><strong>(03) @Target(ElementType.TYPE)</strong></p>
<p>前面我们说过，ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。</p>
<p>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p>
<p>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。</p>
<p><strong>(04) @Retention(RetentionPolicy.RUNTIME)</strong></p>
<p>前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。</p>
<p>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。</p>
<p>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</p>
<h3 id="常用注解-Deprecated"><a href="#常用注解-Deprecated" class="headerlink" title="常用注解 @Deprecated"></a>常用注解 @Deprecated</h3><p>@Deprecated 的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>(01) @interface – 它的用来修饰 Deprecated，意味着 Deprecated 实现了 java.lang.annotation.Annotation 接口；即 Deprecated 就是一个注解。 </p>
<p>(02) @Documented – 它的作用是说明该注解能出现在 javadoc 中。</p>
<p>(03) @Retention(RetentionPolicy.RUNTIME) – 它的作用是指定 Deprecated 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将Deprecated 的信息保留在 .class 文件中，并且能被虚拟机读取。</p>
<p>(04) @Deprecated 所标注内容，不再被建议使用。</p>
<p>例如，若某个方法被 @Deprecated 标注，则该方法不再被建议使用。如果有开发人员试图使用或重写被 @Deprecated 标示的方法，编译器会给相应的提示信息。示例如下:</p>
<p><img src="/2020/03/18/java%E6%B3%A8%E8%A7%A3/2020-03-18-a.jpg" alt></p>
<h3 id="常用注解Inherited"><a href="#常用注解Inherited" class="headerlink" title="常用注解Inherited"></a><strong>常用注解Inherited</strong></h3><p>@Inherited 的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="line">public @interface Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>(01) @interface – 它的用来修饰 Inherited，意味着 Inherited 实现了 java.lang.annotation.Annotation 接口；即 Inherited 就是一个注解。</li>
<li>(02) @Documented – 它的作用是说明该注解能出现在 javadoc 中。</li>
<li>(03) @Retention(RetentionPolicy.RUNTIME) – 它的作用是指定 Inherited 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将 Inherited 的信息保留在 .class 文件中，并且能被虚拟机读取。</li>
<li>(04) @Target(ElementType.ANNOTATION_TYPE) – 它的作用是指定 Inherited 的类型是 ANNOTATION_TYPE。这就意味着，@Inherited 只能被用来标注 “Annotation 类型”。</li>
<li>(05) @Inherited 的含义是，它所标注的Annotation将具有继承性。</li>
</ul>
<p>假设，我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了</p>
<p>MyAnnotation，则 Base 具有了”具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。</p>
<p>@Inherited 的使用示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">## InheritableSon.java</span><br><span class="line"></span><br><span class="line">**import** java.lang.annotation.Target;</span><br><span class="line">**import** java.lang.annotation.ElementType;</span><br><span class="line">**import** java.lang.annotation.Retention;</span><br><span class="line">**import** java.lang.annotation.RetentionPolicy;</span><br><span class="line">**import** java.lang.annotation.Inherited;</span><br><span class="line"></span><br><span class="line">**&#x2F;\**</span><br><span class="line"> \* 自定义的Annotation。</span><br><span class="line"> \*&#x2F;**</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@**interface** Inheritable</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Inheritable</span><br><span class="line">**class** InheritableFather</span><br><span class="line">&#123;</span><br><span class="line">  **public** InheritableFather() &#123;</span><br><span class="line">    *&#x2F;&#x2F; InheritableBase是否具有 Inheritable Annotation*</span><br><span class="line">    System.out.println(&quot;InheritableFather:&quot;+InheritableFather.**class**.isAnnotationPresent(Inheritable.**class**));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**&#x2F;\**</span><br><span class="line"> \* InheritableSon 类只是继承于 InheritableFather，</span><br><span class="line"> \*&#x2F;**</span><br><span class="line">**public** **class** InheritableSon **extends** InheritableFather</span><br><span class="line">&#123;</span><br><span class="line">  **public** InheritableSon() &#123;</span><br><span class="line">    **super**();   *&#x2F;&#x2F; 调用父类的构造函数*</span><br><span class="line">    *&#x2F;&#x2F; InheritableSon类是否具有 Inheritable Annotation*</span><br><span class="line">    System.out.println(&quot;InheritableSon:&quot;+InheritableSon.**class**.isAnnotationPresent(Inheritable.**class**));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  **public** **static** **void** main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line">    InheritableSon is &#x3D; **new** InheritableSon();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InheritableFather:true</span><br><span class="line">InheritableSon:true</span><br></pre></td></tr></table></figure>

<p>现在，我们对 InheritableSon.java 进行修改：注释掉 “Inheritable 的 @Inherited 注解”。</p>
<h2 id="InheritableSon-java"><a href="#InheritableSon-java" class="headerlink" title="InheritableSon.java"></a>InheritableSon.java</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import** java.lang.annotation.Target;</span><br><span class="line">**import** java.lang.annotation.ElementType;</span><br><span class="line">**import** java.lang.annotation.Retention;</span><br><span class="line">**import** java.lang.annotation.RetentionPolicy;</span><br><span class="line">**import** java.lang.annotation.Inherited;</span><br><span class="line"></span><br><span class="line">**&#x2F;\**</span><br><span class="line"> \* 自定义的Annotation。</span><br><span class="line"> \*&#x2F;**</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">*&#x2F;&#x2F;@Inherited*</span><br><span class="line">@**interface** Inheritable</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Inheritable</span><br><span class="line">**class** InheritableFather</span><br><span class="line">&#123;</span><br><span class="line">  **public** InheritableFather() &#123;</span><br><span class="line">    *&#x2F;&#x2F; InheritableBase是否具有 Inheritable Annotation*</span><br><span class="line">    System.out.println(&quot;InheritableFather:&quot;+InheritableFather.**class**.isAnnotationPresent(Inheritable.**class**));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**&#x2F;\**</span><br><span class="line"> \* InheritableSon 类只是继承于 InheritableFather，</span><br><span class="line"> \*&#x2F;**</span><br><span class="line">**public** **class** InheritableSon **extends** InheritableFather</span><br><span class="line">&#123;</span><br><span class="line">  **public** InheritableSon() &#123;</span><br><span class="line">    **super**();   *&#x2F;&#x2F; 调用父类的构造函数*</span><br><span class="line">    *&#x2F;&#x2F; InheritableSon类是否具有 Inheritable Annotation*</span><br><span class="line">    System.out.println(&quot;InheritableSon:&quot;+InheritableSon.**class**.isAnnotationPresent(Inheritable.**class**));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  **public** **static** **void** main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line">    InheritableSon is &#x3D; **new** InheritableSon();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InheritableFather:true</span><br><span class="line">InheritableSon:false</span><br></pre></td></tr></table></figure>

<h4 id="对比上面的两个结果，我们发现：当注解-Inheritable-被-Inherited-标注时，它具有继承性。否则，没有继承性。"><a href="#对比上面的两个结果，我们发现：当注解-Inheritable-被-Inherited-标注时，它具有继承性。否则，没有继承性。" class="headerlink" title="对比上面的两个结果，我们发现：当注解 Inheritable 被 @Inherited 标注时，它具有继承性。否则，没有继承性。"></a>对比上面的两个结果，我们发现：当<u>注解 Inheritable 被 @Inherited 标注</u>时，它具有继承性。否则，没有继承性。</h4><h2 id="Annotation-的作用"><a href="#Annotation-的作用" class="headerlink" title="Annotation 的作用"></a>Annotation 的作用</h2><p>Annotation 是一个辅助类，它在 Junit、Struts、Spring 等工具框架中被广泛使用。</p>
<p>我们在编程中经常会使用到的 Annotation 作用有：</p>
<h3 id="1）编译检查"><a href="#1）编译检查" class="headerlink" title="1）编译检查"></a>1）编译检查</h3><p>Annotation 具有”让编译器进行编译检查的作用”。</p>
<h3 id="2-在反射中使用-Annotation"><a href="#2-在反射中使用-Annotation" class="headerlink" title="2) 在反射中使用 Annotation"></a>2) 在反射中使用 Annotation</h3><h3 id="3-根据-Annotation-生成帮助文档"><a href="#3-根据-Annotation-生成帮助文档" class="headerlink" title="3) 根据 Annotation 生成帮助文档"></a>3) 根据 Annotation 生成帮助文档</h3><p>通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。</p>
<h3 id="4-能够帮忙查看查看代码"><a href="#4-能够帮忙查看查看代码" class="headerlink" title="4) 能够帮忙查看查看代码"></a>4) 能够帮忙查看查看代码</h3><p>通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。</p>
<p>另外，我们也可以通过自定义 Annotation 来实现一些功能。</p>
<p>参考资料：</p>
<blockquote>
<p>原文地址：<a href="https://www.cnblogs.com/skywang12345/p/3344137.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3344137.html</a></p>
<p>摘录自：<a href="https://www.runoob.com/w3cnote/java-annotation.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/java-annotation.html</a></p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-Basic%EF%BC%9BAnnotation%EF%BC%9B/" rel="tag">Java;Basic；Annotation；</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-postgreSQL-SHA-256" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/10/postgreSQL-SHA-256/"
    >postgreSQL:SHA-256算法分析</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/10/postgreSQL-SHA-256/" class="article-date">
  <time datetime="2020-03-10T11:02:08.000Z" itemprop="datePublished">2020-03-10</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>由于数据库系统实现课程要求,对postgreSQL数据库进行了部分分析。</p>
<p>我负责的部分是SHA-256安全认证机制的分析，所以今天把分析成果稍稍展示一下。SHA-256是一个哈希函数，负责将传递的消息进行加密，得到256-bit的加密过的消息摘要。所以下面会介绍如何通过SHA-256将一条信息逐步加密：</p>
<h2 id="SHA-256算法实现"><a href="#SHA-256算法实现" class="headerlink" title="SHA-256算法实现"></a>SHA-256算法实现</h2><h3 id="前置条件："><a href="#前置条件：" class="headerlink" title="前置条件："></a>前置条件：</h3><ul>
<li>32-bit 是SHA-256的最小基本处理单元。</li>
<li>SHA-256规定8个哈希值和64个哈希常量，皆为32-bit。</li>
<li>消息预处理，将消息附加填充位（100……000）和附加长度信息，使其</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息原本长度+附加填充位长度（长度随随情况而定）+64（长度信息的位数）&#x3D;&#x3D;512的整数倍</span><br></pre></td></tr></table></figure>



<h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><ol>
<li><p>将消息分成n个512-bit大小的块</p>
<p><img src="/2020/03/10/postgreSQL-SHA-256/2020-03-09-a.png" alt="分解图"></p>
</li>
<li><p>将每个块分解成基本单元word，可以直接分成16个word，再通过这16个word 构造出其余48个word，这一步共得出64个word ，w[0]…w[63] </p>
</li>
<li><p>进行n次迭代，n是消息分成的块数。消息摘要的初始值是8个哈希值</p>
</li>
</ol>
<img src="/2020/03/10/postgreSQL-SHA-256/2020-03-09-c.png" alt="初始值" style="zoom:60%;">

<p>每一次迭代中，通过旧消息摘要和Mi由映射函数将其计算得到新消息摘要，再将新消息摘要作为下一次迭代的一个输入，重复n次。</p>
<img src="/2020/03/10/postgreSQL-SHA-256/2020-03-09-b.png" alt="迭代图" style="zoom:60%;">



<h2 id="映射函数："><a href="#映射函数：" class="headerlink" title="映射函数："></a>映射函数：</h2><p><img src="/2020/03/10/postgreSQL-SHA-256/2020-03-09-d.png" alt="映射函数"></p>
<p>映射关系是每次迭代过程中会进行的数值计算。</p>
<p>上图中，每次计算新消息摘要会进行64次循环计算；蓝色方框代表固定逻辑函数；红色方框代表取余运算，使结果不超过2^32。</p>
<p>每次计算的输入：</p>
<ul>
<li>旧消息摘要（初始摘要或者上次计算结果）</li>
<li>Wt 每一个块消息分解产生的64个word，依次序加入计算</li>
<li>Kt 64个哈希常量，依次加入计算</li>
</ul>
<p>计算的输出：</p>
<ul>
<li>一个新的最小单元32-bit的数据，即word[A]</li>
</ul>
<p>计算结果：由word[A]开头，其余7个word 由旧消息摘要右移32-bit组成的消息摘要。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SHA是一个多重计算过程的算法，理解起来不难：大循环套小循环计算。</p>
<p>计算量不知道；现行破解可能性不知道。</p>
<p>参考资料：<a href="https://blog.csdn.net/u011583927/article/details/80905740" target="_blank" rel="noopener">CSDN-随煜而安</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/database-SHA-256-algorithm/" rel="tag">database;SHA-256;algorithm</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-从Halo开始：学习Gradle" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/07/%E4%BB%8EHalo%E5%BC%80%E5%A7%8B%EF%BC%9A%E5%AD%A6%E4%B9%A0Gradle/"
    >从Halo开始：学习Gradle</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/07/%E4%BB%8EHalo%E5%BC%80%E5%A7%8B%EF%BC%9A%E5%AD%A6%E4%B9%A0Gradle/" class="article-date">
  <time datetime="2020-03-07T06:01:17.000Z" itemprop="datePublished">2020-03-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="Halo"><a href="#Halo" class="headerlink" title="Halo"></a>Halo</h2><p>在GitHub上的一个轻量级开源项目，一款现代化的个人独立博客系统。</p>
<p>非学习用开源项目，但如果能通过自己理解项目构建、源码，对初学者来说，未必不是一个好的选择。</p>
<h2 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h2><p>将程序自动化的构建工具，集编译源代码、运行测试、拷贝Class文件到目标目录、签名、打包、依赖管理等功能于一体。</p>
<p>构建包括编译、连接以及打包。通过Gradle，能做什么？</p>
<ul>
<li>下载依赖</li>
<li>源码编译成二进制代码</li>
<li>打包生成的二进制代码</li>
<li>进行单元测试</li>
<li>部署到生产系统</li>
</ul>
<p>依赖部署如果仅仅依靠手动配置，是很麻烦容易出错，无法成为可行商用化的成果。</p>
<h2 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h2><p>现在没有学习gradle的使用，仅分析Halo项目中build.gradle文件的各行代码的意义。</p>
<p>通过注释+文档的形式来学习。</p>
<p>gradle 采用以下形式来调用构建脚本块:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">脚本块名&#123;</span><br><span class="line">       执行语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细查看官网：<a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">Gradle</a></p>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p><strong>plugins</strong> 中文译意：插件；外挂</p>
<p>DSL，用于声明要在脚本中使用的插件。</p>
<p>使用时，该<code>plugins {}</code>块仅允许使用完整构建脚本编程语言的严格子集。值必须是文字的（例如，常量字符串，而不是变量）。允许插入字符串<code>PluginDependencySpec.version(java.lang.String)</code>，但是替换值必须来自Gradle属性。</p>
<p>此外，该<code>plugins {}</code>块必须是构建脚本的第一个代码。对此有一个例外，因为<code>buildscript {</code>}块（用于声明脚本依赖项）必须位于它之前。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><em>使用方法</em></h3><h4 id="PluginDependencySpec-id-String-id"><a href="#PluginDependencySpec-id-String-id" class="headerlink" title="PluginDependencySpec id(String id)"></a><code>PluginDependencySpec id(String id)</code></h4><p>在具有给定id的插件上添加依赖项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &quot;org.company.myplugin&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过返回值的方法指定其他约束（例如版本号）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &quot;org.company.myplugin&quot; version &quot;1.3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，插件会自动应用于当前脚本。可以使用以下<code>apply false</code>选项禁用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &quot;org.company.myplugin&quot; version &quot;1.3&quot; apply false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用的插件"><a href="#使用的插件" class="headerlink" title="使用的插件"></a>使用的插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot</span><br></pre></td></tr></table></figure>

<p>需要使用SpringBoot 而插入的插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.freefair.lombok</span><br></pre></td></tr></table></figure>

<p>自动lombok和delombok配置的插件</p>
<p>lombok 是Java库，Lombok提供了一组有用的注解，通过“<strong><em>@注解名</em></strong> ”的方法实现。</p>
<p>如：@Setter ：注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。</p>
<p>@Getter ：使用方法同上，区别在于生成的是getter方法。</p>
<p>@ToString ：注解在类，添加toString方法。</p>
<p>@EqualsAndHashCode： 注解在类，生成hashCode和equals方法。</p>
<p>@NoArgsConstructor： 注解在类，生成无参的构造方法。</p>
<p>@RequiredArgsConstructor： 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。</p>
<p>@AllArgsConstructor： 注解在类，生成包含类中所有字段的构造方法。</p>
<p>@Data： 注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkstyle</span><br></pre></td></tr></table></figure>

<p>代码检查;检查源文件编码规范。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.spring.dependency-management</span><br></pre></td></tr></table></figure>

<p>提供类似Maven的依赖管理功能的Gradle插件。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Personal-study-notes-Unprofessional/" rel="tag">Personal study notes;Unprofessional</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-我的第一篇博客文章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"
    >我的第一篇博客文章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/02/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" class="article-date">
  <time datetime="2020-02-27T08:32:19.000Z" itemprop="datePublished">2020-02-27</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>通过bilibili上观看codesheep 的视频，成功搭建基于 github库上 hexo博客</p>
<p>感谢up主和弹幕大佬们</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>因为确实是技术小白，视频中有很多名词是今天才接触到或者说是去了解它。</p>
<p>首先是hexo：一种blog框架，前置配置是git和node.js</p>
<p>其次是git和node.js：git – 开源的分布式版本控制系统 ，所以这里需要我去多多了解git及github的工作。node.js– Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 </p>
<p>然后是markdown格式及其编辑与工具typora:<br>markdown是一种实用的纯文本标记语言，通过typora可以在展示格式和源码格式编辑。</p>
<p>最后是重新唤起了命令行的操作方式的记忆，命令行是程序员经常会使用的工具，小白还是多使用为妙。</p>
<p>定下一个小目标，学习Java及上手开源实践项目，为以后的发展奠定基础。</p>
<hr>
<h4 id="参考文件：程序羊"><a href="#参考文件：程序羊" class="headerlink" title="参考文件：程序羊"></a>参考文件：<a href="www.codesheep.cn">程序羊</a></h4>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-hello-world" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/27/hello-world/"
    >Hello World</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/02/27/hello-world/" class="article-date">
  <time datetime="2020-02-27T08:09:57.491Z" itemprop="datePublished">2020-02-27</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        YHang-tech
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="YHang-tech&#39;s Personal Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/share.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/js/ayer.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>