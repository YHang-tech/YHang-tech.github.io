<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Springboot-Oracle-database(2)</title>
    <url>/2020/04/23/Springboot-Oracle-database-2/</url>
    <content><![CDATA[<h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><p>接上一章,完成相关配置后，终于可以运行项目，并成功在网页上，通过网址传参的方法显示数据库数据。</p>
<p><img src="/2020/04/23/Springboot-Oracle-database-2/spb3.2-1.png" alt></p>
<h2 id="Mapper：映射器-StudentMapper类"><a href="#Mapper：映射器-StudentMapper类" class="headerlink" title="Mapper：映射器-StudentMapper类"></a>Mapper：映射器-StudentMapper类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Insert</span>(<span class="string">"insert into student(sno,sname,ssex) values(#&#123;sno,jdbcType=VARCHAR&#125;,#&#123;name,jdbcType=VARCHAR&#125;,#&#123;sex,jdbcType=CHAR&#125;)"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(Student student)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Update</span>(<span class="string">"update student set sname=#&#123;name,jdbcType=VARCHAR&#125;,ssex=#&#123;sex,jdbcType=VARCHAR&#125; where sno=#&#123;sno,jdbcType=VARCHAR&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Student student)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Delete</span>(<span class="string">"delete from student where sno=#&#123;sno,jdbcType=VARCHAR&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteBysno</span><span class="params">(String sno)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Select</span>(<span class="string">"select * from student where sno=#&#123;sno,jdbcType=VARCHAR&#125;"</span>)</span><br><span class="line">   <span class="meta">@Results</span>(id = <span class="string">"student"</span>,value= &#123;</span><br><span class="line">       <span class="meta">@Result</span>(property = <span class="string">"sno"</span>, column = <span class="string">"sno"</span>, javaType = String<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">         @<span class="title">Result</span>(<span class="title">property</span> </span>= <span class="string">"name"</span>, column = <span class="string">"sname"</span>, javaType = String<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">         @<span class="title">Result</span>(<span class="title">property</span> </span>= <span class="string">"sex"</span>, column = <span class="string">"ssex"</span>, javaType = String<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">   &#125;)</span></span><br><span class="line"><span class="class">    <span class="title">Student</span> <span class="title">queryStudentBySno</span>(<span class="title">String</span> <span class="title">sno</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="component"><a href="#component" class="headerlink" title="@component"></a>@component</h4><p>实现类中用到了@Autowired注解，被注解的这个类是从Spring容器中取出来的，那调用的实现类也需要被Spring容器管理，加上@Componenat。</p>
<p>与此类似的注解有：</p>
<p>1、@controller （注入服务），标注控制层组件。</p>
<p>2、@service （注入dao），标注业务层组件。</p>
<p>3、@repository （实现dao访问），标注数据访问组件。</p>
<p>4、@component （把普通pojo实例化到spring容器中，相当于配置文件中的<bean id class>），泛指组件。</bean></p>
<p>　 <strong>@Component,@Service,@Controller,@Repository注解的类，并把这些类纳入进spring容器中管理</strong></p>
<p>@component（），参数为组件名，可以通过此ID使用bean。</p>
<h4 id="Mapper"><a href="#Mapper" class="headerlink" title="@Mapper"></a>@Mapper</h4><h5 id="Mapper注解，目的就是为了不再写mapper映射文件（不好写）。"><a href="#Mapper注解，目的就是为了不再写mapper映射文件（不好写）。" class="headerlink" title="@Mapper注解，目的就是为了不再写mapper映射文件（不好写）。"></a>@Mapper注解，目的就是为了不再写mapper映射文件（不好写）。</h5><p>添加@Mapper注解后，这个<strong>接口</strong>在编译时会生成相应的<strong>实现类</strong>。但不支持同名方法。</p>
<h4 id="数据库操纵函数"><a href="#数据库操纵函数" class="headerlink" title="数据库操纵函数"></a>数据库操纵函数</h4><p>通过@Insert、@update、@select、@delete等注解，将SQL语言插入。</p>
<p>参数传递可以单独用values指定如 values(#{sno,jdbcType=VARCHAR} ，用jdbcType限定类型，不然会出现传值为NULL错误。也可以嵌在SQL语句中。</p>
<hr>
<h2 id="项目思路："><a href="#项目思路：" class="headerlink" title="项目思路："></a>项目思路：</h2><p>从controller开始，在TestController类中有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StudentService studentService;</span><br></pre></td></tr></table></figure>

<p>自动装配StudentService，寻找bean ID为studentservice的类，接口StudentService的实现类StudentServiceImp，有注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"studentService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImp</span> <span class="keyword">implements</span> <span class="title">StudentService</span></span></span><br></pre></td></tr></table></figure>

<p>所以应该是用StudentServiceImp，去实例化了studentService。</p>
<p>而StudentServiceImp又有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StudentMapper studentMapper;</span><br></pre></td></tr></table></figure>

<p>自动装配studentMapper，寻找bean ID为StudentMapper的类，在mapper目录下的StudentMapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span></span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.cnblogs.com/lyjing/p/8427832.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyjing/p/8427832.html</a></p>
<p><a href="https://blog.csdn.net/phenomenonsTell/article/details/79033144?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2" target="_blank" rel="noopener">我也不知道该叫啥</a></p>
]]></content>
      <tags>
        <tag>Java;SpringBoot;Oracle;</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot_Oracle_database</title>
    <url>/2020/04/21/Springboot-Oracle-database/</url>
    <content><![CDATA[<h2 id="SpringBoot-连接数据库"><a href="#SpringBoot-连接数据库" class="headerlink" title="SpringBoot 连接数据库"></a>SpringBoot 连接数据库</h2><h4 id="开源项目SpringAll所提供的第三章Spring-Boot-MyBatis"><a href="#开源项目SpringAll所提供的第三章Spring-Boot-MyBatis" class="headerlink" title="开源项目SpringAll所提供的第三章Spring-Boot-MyBatis"></a>开源项目SpringAll所提供的第三章Spring-Boot-MyBatis</h4><hr>
<h2 id="ojdbc6-dependency错误–相关配置"><a href="#ojdbc6-dependency错误–相关配置" class="headerlink" title="ojdbc6-dependency错误–相关配置"></a>ojdbc6-dependency错误–相关配置</h2><p>首先试运行项目，自动Sync时出错，错误：</p>
<ul>
<li><p>Cannot resolve com.oracle:ojdbc6:11.2.0.4.0</p>
<p>原因：由于oracle官方未授权，所以maven上无法直接下载ojdbc，需要自己下载，然后通过命令加载到本地maven库中</p>
</li>
</ul>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>手动下载并配置到自己的Maven库中。</p>
<p>1 . 下载ojdbc，进入IDEA右侧的database选项，点击+号，选择Driver选项：</p>
<img src="/2020/04/21/Springboot-Oracle-database/spb3_1.png" style="zoom:80%;">

<p>2 . 在Drivers中选中Oracle，在右侧配置项中选择你所需要的ojdbc-version，(有可能需要将Class从oracle.jdbc.driver.OracleDriver改为oracle.jdbc.OracleDriver  )选择过后，系统会为你自动下载，记住下载地址：</p>
<p><img src="/2020/04/21/Springboot-Oracle-database/spb3_2.png" alt></p>
<p>3 . 从下载地址中找到ojdbc6-11.2.0.4.jar ，例如我的地址是”C:\Users\yanghang.IntelliJIdea2019.2\config\jdbc-drivers\Oracle\11.2.0.4\ojdbc6-11.2.0.4.jar”，将它复制到E:\ 下。</p>
<p>4 . 进入命令行，输入命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=<span class="number">11.2</span><span class="number">.0</span><span class="number">.4</span><span class="number">.0</span> -Dpackaging=jar -Dfile=E:\ ojdbc6<span class="number">-11.2</span><span class="number">.0</span><span class="number">.4</span>.jar</span><br></pre></td></tr></table></figure>

<p>这样就可以配置进自己的Maven库了。</p>
<p>5 . 同时还需要修改pom.xml文件的引入依赖项。将groupId修改为com.oracle:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc6<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>11.2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>6 . 点击Reimport按钮，观察是否导入依赖。</p>
<hr>
<h2 id="配置Project-Data-Source"><a href="#配置Project-Data-Source" class="headerlink" title="配置Project Data Source"></a>配置Project Data Source</h2><p>要继续使用Oracle 数据库，还需要配置数据来源：</p>
<img src="/2020/04/21/Springboot-Oracle-database/spb3_3.png" style="zoom:80%;">

<p>点击+号，选择Data Source–&gt;Oracle 进行配置。</p>
<p>Oracle默认URL为 thin：@localhost：1521：ORCL。选择一个有效的Oracle User和Password。</p>
<img src="/2020/04/21/Springboot-Oracle-database/spb3_4.png" style="zoom:80%;">

<p>点击Test Connection，此处很容易出现错误。</p>
<p>我的错误是：connection refused:connect ，原因，没有下载Oracle客户端。</p>
<p>下载过后，从SQLplus进入，创建一个User：TEST ，password： 123456 的用户。</p>
<hr>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://blog.csdn.net/zhihaoma/article/details/82896071" target="_blank" rel="noopener">https://blog.csdn.net/zhihaoma/article/details/82896071</a></p>
]]></content>
      <tags>
        <tag>Java;SprinBoot;Oracle;</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot_config</title>
    <url>/2020/04/19/SpringBoot-config-1/</url>
    <content><![CDATA[<h2 id="SpringBoot-项目目录结构"><a href="#SpringBoot-项目目录结构" class="headerlink" title="SpringBoot 项目目录结构"></a>SpringBoot 项目目录结构</h2><h4 id="一、代码层结构"><a href="#一、代码层结构" class="headerlink" title="一、代码层结构"></a>一、代码层结构</h4><h5 id="根目录：com-bajins"><a href="#根目录：com-bajins" class="headerlink" title="根目录：com.bajins"></a>根目录：com.bajins</h5><ul>
<li><p>启动类 BajinsApplication.java直接放在根目录com.bajins包下</p>
</li>
<li><p>数据实体类domain ：</p>
<p>​    jpa 项目：com.bajins.domain 包</p>
<p>​    mybatis 项目： com.bajins.entity 包</p>
</li>
<li><p>数据接口访问层Dao ：</p>
<p>​    jpa 项目：com.bajins.respository 包</p>
<p>​    mybatis 项目： com.bajins.mapper 包</p>
</li>
<li><p>数据服务接口层Service : com.bajins.service 包</p>
</li>
<li><p>数据服务接口实现层 Service Implements: com.bajins.service.impl 包</p>
</li>
<li><p>前端控制器层 Controller: com.bajins.controller 包</p>
</li>
<li><p>工具类库 utils : com.bajins.utils 包</p>
</li>
<li><p>配置类 config: com.bajins.config 包</p>
</li>
<li><p>数据传输对象 dto: com.bajins.dto 包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据传输对象Data Transfer Object 用于封装多个实体类 domain之间的关系，不破坏原有的实体结构类。</span><br></pre></td></tr></table></figure>
</li>
<li><p>视图包装对象 vo: com.bajins.vo 包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">视图包装对象 View Object用于封装客户端请求的数据，防止部分数据泄露 如：管理员ID，保证数据安全，不破坏原有的实体结构。</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量类 constant: com.bajins.constant 包</p>
</li>
</ul>
<h4 id="二、资源目录结构"><a href="#二、资源目录结构" class="headerlink" title="二、资源目录结构"></a>二、资源目录结构</h4><h5 id="根目录：resources"><a href="#根目录：resources" class="headerlink" title="根目录：resources"></a>根目录：resources</h5><ul>
<li>application.properties 等 .properties文件</li>
<li>项目配置文件： resources/application.yml</li>
<li>静态资源目录： resources/static/  ;用于存放html、css、js、图片等资源</li>
<li>视图模板目录： resources/templates/  ;用于存放jsp、thymeleaf等模板文件</li>
<li>mybatis映射文件：resources/mappers/</li>
<li>mybatis配置文件：resources/spring-mybatis.xml</li>
</ul>
<hr>
<h2 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h2><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>让 用了@ConfigurationProperties的类的注解生效。</p>
<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>如果一个配置类只配置@ConfigurationProperties注解，而没有使用@Component，那么在IOC容器中是获取不到properties 配置文件转化的bean。说白了 @EnableConfigurationProperties 相当于把使用  @ConfigurationProperties 的类进行了一次注入。</p>
<p><code>@EnableConfigurationProperties</code> 文档中解释：<br> 当<code>@EnableConfigurationProperties</code>注解应用到你的<code>@Configuration</code>时， 任何被<code>@ConfigurationProperties</code>注解的beans将自动被Environment属性配置。 这种风格的配置特别适合与SpringApplication的外部YAML配置进行配合使用。</p>
<h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><p>在编写项目代码时，我们需要更灵活的配置，更好的模块化整合。</p>
<p>在SpringBoot 项目中，为满足以上要求，我们将大量参数配置在application.properties或application.yml 。通过@ConfigurationProperties 注解，可以方便的获得这些参数值。</p>
<h4 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h4><p>我们可以使用 <code>@Value</code> 注解或着使用 Spring <code>Environment</code> bean 访问这些属性，但是这种注入配置方式有时显得很笨重。我们将使用更安全的方式(<code>@ConfigurationProperties</code> )来获取这些属性</p>
<h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:test.properties"</span>)</span><br></pre></td></tr></table></figure>

<p>选择property的路径，默认为application.properties。有需要的configuratin要加上这一句。</p>
<hr>
<h2 id="Spring-Boot-Config项目"><a href="#Spring-Boot-Config项目" class="headerlink" title="Spring-Boot-Config项目"></a>Spring-Boot-Config项目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;ConfigBean<span class="class">.<span class="keyword">class</span>,<span class="title">TestConfigBean</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication app = <span class="keyword">new</span> SpringApplication(Application<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		app.setAddCommandLineProperties(<span class="keyword">false</span>);</span><br><span class="line">		app.run(args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主类使用@EnableConfigurationProperties （），参数为使用了@ConfigurationProperties的两个类的类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"mrbird.blog"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigBean</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如：ConfigBean类，使用@ConfigurationProperties，参数为指定前缀“mrbird.blog”,这就意味着name的属性值被绑定为application.properties配置文件中的mrbird.blog.name=”mr’s blog</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlogProperties</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Value</span>(value = <span class="string">"$&#123;mrbird.blog.name&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<p>同样，在使用@Component的类使用@Value也能达到注入属性值的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@Value(&quot;mrbird&quot;) @Value(&quot;value &#x3D; &quot;mrbird&quot;&quot;) @Value(&quot;$&#123;mrbird.blog.name&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>和上述方法都能达到注入属性值的目的，但推荐使用第一种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> BlogProperties blogProperties;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> ConfigBean configBean;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">   <span class="function">String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> blogProperties.getName()+blogProperties.getTitle();</span><br><span class="line">      <span class="comment">/*ConfigBean.getName()+"，"+ConfigBean.getAge();*/</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制器类中，使用@Autowired 自动连接配置类以创建实例。此时如一般类一样访问类方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*application.properties 文件*/</span></span><br><span class="line">mrbird.blog.name=mrbird<span class="string">'s blog</span></span><br><span class="line"><span class="string">mrbird.blog.title=Spring Boot</span></span><br><span class="line"><span class="string">mrbird.blog.wholeTitle=$&#123;mrbird.blog.name&#125;--$&#123;mrbird.blog.title&#125;</span></span><br><span class="line"><span class="string">/*可以在配置文件中引用属性值*/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">spring.profiles.active=prod</span></span><br><span class="line"><span class="string">    /*修改此属性可以引用不同文件，下两个文件分别存放不同的端口值。</span></span><br><span class="line"><span class="string">当然，直接使用server.port也可以直接达到修改端口值的目的</span></span><br><span class="line"><span class="string">server.port在此文件中配置后可以直接生效*/</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">/*application-dev.properties */</span></span><br><span class="line"><span class="string">server.port=8080</span></span><br><span class="line"><span class="string">/*applocation-prod.properties */</span></span><br><span class="line"><span class="string">server.port=8081</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://blog.csdn.net/qq_39615545/article/details/90172038?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">CSDN-www.bajins.com</a></p>
<p><a href="https://www.jianshu.com/p/7f54da1cb2eb" target="_blank" rel="noopener">简书-咪雅先森</a></p>
<p><a href="https://www.jianshu.com/p/7f75936b573b" target="_blank" rel="noopener">简书-日拱一兵</a></p>
]]></content>
      <tags>
        <tag>Java;SpringBoot;</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello SpringBoot</title>
    <url>/2020/04/17/Hello-SpringBoot/</url>
    <content><![CDATA[<h2 id="Hello-SpringBoot"><a href="#Hello-SpringBoot" class="headerlink" title="Hello SpringBoot"></a>Hello SpringBoot</h2><p>学习springboot ，从github上寻找了很多个关于springboot 的开源项目。最终敲定–SpringAll。</p>
<p>第一章，开始搭建环境并成功运行项目。</p>
<h3 id><a href="#" class="headerlink" title></a><img src="/2020/04/17/Hello-SpringBoot/spb1_picture1.PNG" alt></h3><hr>
<h2 id="SpringBoot注解"><a href="#SpringBoot注解" class="headerlink" title="SpringBoot注解"></a>SpringBoot注解</h2><p>一般情况下，通过注解@SpringBootApplication来启动SpringBoot项目</p>
<p>一般情况下，通过注解@SpringBoot和@RunWith(SpringRunner.class)来启动SpringBoot测试项目</p>
<h4 id="SpringBootApplication-和-SpringBootTest-的区别"><a href="#SpringBootApplication-和-SpringBootTest-的区别" class="headerlink" title="@SpringBootApplication 和 @SpringBootTest 的区别"></a>@SpringBootApplication 和 @SpringBootTest 的区别</h4><p>这两个注解的区别的核心在于两个注解：@EnableAutoConfiguration、@ComponentScan(包含了两个filter)</p>
<p>@EnableAutoConfiguration 启动了所有的自动配置类</p>
<p>@ComponentScan(包含了两个filter)：在扫描阶段过滤掉 @TestComponent 等专属于测试的类和过滤<strong>掉被 @Configuration 注解的自动配置类</strong>（使得自动配置类不会在扫描阶段就被注册 beanDefinition，因为 自动配置类的优先级应该是最低的）</p>
<p>可以看出 @SpringBootTest 并没有启用任何自动配置类，所以就不需要加 AutoConfigurationExcludeFilter 了</p>
<p>springboot 通过引入 @Test** 注解来在 测试环境下 引入不同的自动配置类！</p>
<hr>
<h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><h6 id="restController的作用等同于-Controller和-ResponseBody"><a href="#restController的作用等同于-Controller和-ResponseBody" class="headerlink" title="@restController的作用等同于@Controller和 @ResponseBody"></a>@restController的作用等同于@Controller和 @ResponseBody</h6><h4 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h4><p>在一个类上添加@Controller注解，表明了这个类是一个控制器类。</p>
<p>但想要让这个类成为一个处理请求的处理器光有@Controller注解是不够的，他还需要进一步修炼才能成为一个处理器。</p>
<p>在spring容器中创建该类的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-scan=<span class="string">"test.controller"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>这种方式会扫描指定包中的所有controller注解的类，并生成相应的bean注入到spring容器中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"test"</span> &gt;</span><br><span class="line">  　　&lt;context:include-filter type=<span class="string">"annotation"</span> 														expression=<span class="string">"org.springframework.stereotype.Service"</span>/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<p>上述代码表示扫描test包中除有@Service注解之外的类。</p>
<hr>
<h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>将@Controller注解的类注入Spring容器中，只是该类成为处理器的第一步，想要修炼大成，还需要在该<strong>类中添加注解@RequestMapping</strong>。</p>
<p>@RequestMapping注解是用来映射请求的，即指明该处理器可以处理哪些URL请求。</p>
<p>@RequestMapping既可以用在方法上，又可以用在类上。当使用@RequestMapping标记控制器类时，方法的请求地址是相对类的请求地址而言的；当没有使用@RequestMapping标记类时，方法的请求地址是绝对路径。</p>
<p>@RequestMapping的地址可以是uri变量，并且通过@PathVariable注解获取作为方法的参数。也可以是通配符来筛选请求地址。</p>
<hr>
<h2 id="入口：SpringBootApplication-run"><a href="#入口：SpringBootApplication-run" class="headerlink" title="入口：SpringBootApplication.run()"></a>入口：SpringBootApplication.run()</h2><p>这个就是springboot的启动命令，运行main，执行这一句，SpringApplication是一个定义好的类。<strong>run的参数内是当前类的class，和main的参数</strong>，他会找到上面的@springbootapplication注解开始进行你所做的所有配置。</p>
<h2 id="页面显示-RequestMapping"><a href="#页面显示-RequestMapping" class="headerlink" title="页面显示:@RequestMapping"></a>页面显示:@RequestMapping</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">	<span class="function">String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"hello spring boot"</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>返回一个string 的字符串到页面上。</p>
<p>@RequestMapping注解，当访问对应网址时，可以返回函数值。此处为localhost：8080有效。</p>
<p>@RequestMapping 相当于@respondBody和@Mapping，@Mapping注解规定后缀网址，@RespondBody注解声明此函数可以映射属性值到网页中。</p>
<p>若删去，网址错误：</p>
<p><img src="/2020/04/17/Hello-SpringBoot/spc1_picture2.PNG" alt></p>
<hr>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://blog.csdn.net/kangsa998/article/details/97940760" target="_blank" rel="noopener">CSDN-开心小蜗牛</a></p>
<p><a href="https://www.cnblogs.com/yaqee/p/11256047.html" target="_blank" rel="noopener">博客园-qee</a></p>
]]></content>
      <tags>
        <tag>Java;SpringBoot;</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_创建型模式</title>
    <url>/2020/04/01/Java-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>某个类只能有一个实例，提供一个全局的访问点。</p>
<p>对于某些系统，只有一个实例很重要，例如一个系统只能有一个窗口管理器或文件系统。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>只有一个实例；</li>
<li>必须自行创建这个实例；</li>
<li>提供全局访问点，即向整个系统提供这个实例。</li>
</ul>
<h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><p>大致思想：在类中定义一个静态实例，保证只有一个实例，该实例通过静态公有方法GetInstance方法获取（如果实例不为NULL，为NULL则初始化后再返回）。</p>
<p>​                    构造方法为私有，确保无法直接通过new直接实例化。</p>
<p>考虑到多线程是否安全、效率高低，在实现方式有差异：饿汉式、饱汉式、懒汉式、静态内部类、双重锁。</p>
<h5 id="介绍一种：饱汉式"><a href="#介绍一种：饱汉式" class="headerlink" title="介绍一种：饱汉式"></a>介绍一种：饱汉式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**  </span><br><span class="line"> * 方法二</span><br><span class="line"> * 单例模式的实现：饱汉式,非线程安全   </span><br><span class="line"> * 方法二就是传说的中的饱汉模式</span><br><span class="line"> * 优点是：写起来比较简单，当类SingletonTest被加载的时候，静态变量static的instance未被创建并分配内存空间，</span><br><span class="line"> * 当getInstance方法第一次被调用时，初始化instance变量，并分配内存，因此在某些特定条件下会节约了内存；</span><br><span class="line"> * 缺点是：并发环境下很可能出现多个SingletonTest实例。  </span><br><span class="line"> *&#x2F;  </span><br><span class="line">class SingletonTest2 &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义私有构造方法（防止通过 new SingletonTest()去实例化）</span><br><span class="line">    private SingletonTest2() &#123;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 定义一个SingletonTest类型的变量（不初始化，注意这里没有使用final关键字）</span><br><span class="line">    private static SingletonTest2 instance;   </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 定义一个静态的方法（调用时再初始化SingletonTest，但是多线程访问时，可能造成重复初始化问题）</span><br><span class="line">    public static SingletonTest2 getInstance() &#123;   </span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">		instance &#x3D; new SingletonTest2();</span><br><span class="line">	&#125;   </span><br><span class="line">        return instance;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h5><p>单例模式的主要优点就是节约系统资源、提高了系统效率，同时也能够严格控制客户对它的访问。也许就是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，所以扩展起来有一定的困难。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>抽象工厂模式的孪生兄弟。</p>
<p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。</p>
<p>也就是说工厂方法模式让实例化推迟到子类</p>
<p>十分符合“开闭原则”。</p>
<h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统。</li>
<li>每新增一个新产品时就必须增加两个类。</li>
<li>工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象。</li>
<li>由工厂子类来确定究竟应该实例化哪一个具体产品类，即用户只需知道具体的子工厂。</li>
</ul>
<h5 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h5><p>定义一个接口，不同子类来继承这个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ComputerFactory2</span></span>&#123;</span><br><span class="line">	<span class="function">Game <span class="title">playGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LOLFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory2</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Game <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LOL();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DNFFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory2</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Game <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DNF();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WOWFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory2</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Game <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> WOW();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 工厂方法模式</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 优点:扩展性高</span></span><br><span class="line"><span class="comment">		 * 缺点:增加了复杂度</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Game game3=<span class="keyword">new</span> LOLFactory().playGame();</span><br><span class="line">		Game game4=<span class="keyword">new</span> DNFFactory().playGame();</span><br><span class="line">		Game game5=<span class="keyword">new</span> WOWFactory().playGame();</span><br><span class="line">		game3.play();</span><br><span class="line">		game4.play();</span><br><span class="line">		game5.play();</span><br></pre></td></tr></table></figure>



<h2 id="简单工厂模式："><a href="#简单工厂模式：" class="headerlink" title="简单工厂模式："></a>简单工厂模式：</h2><p>很简单，由条件创建不同子类对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Game game&#x3D; ComputerFactory.playGame(LOL);</span><br><span class="line">Game game2&#x3D; ComputerFactory.playGame(DNF);</span><br><span class="line"></span><br><span class="line">class ComputerFactory&#123;</span><br><span class="line">	private static final String LOL&#x3D;&quot;LOL&quot;; </span><br><span class="line">	private static final String DNF&#x3D;&quot;DNF&quot;; </span><br><span class="line">	&#x2F;&#x2F;玩游戏</span><br><span class="line">	 public static Game playGame(String game)&#123;</span><br><span class="line">		 if(LOL.equalsIgnoreCase(game))&#123;</span><br><span class="line">			 return new LOL();</span><br><span class="line">		 &#125;else if(DNF.equalsIgnoreCase(game))&#123;</span><br><span class="line">			 return new DNF();</span><br><span class="line">		 &#125;</span><br><span class="line">		 return null;</span><br><span class="line">	 &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h2><h5 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h5><p>使用情况，一个工厂提供多个产品（工厂方法模式只能有一个产品）</p>
<p>抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。</p>
<ul>
<li><strong>产品族</strong> ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</li>
</ul>
<h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><p>允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。</p>
<p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p>
<h5 id="实现：-2"><a href="#实现：-2" class="headerlink" title="实现："></a>实现：</h5><p>一个接口中多种抽象方法。</p>
<p>继承的子类重写每种方法，每种方法对应一个产品。</p>
<p>用父接口去指代实例，即不用知道实际产品，但需要知道生产方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface ComputerFactory3&#123;</span><br><span class="line">   Game playGame();</span><br><span class="line">   </span><br><span class="line">   Game playGame2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PVPFactory implements ComputerFactory3&#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public Game playGame() &#123;</span><br><span class="line">      return new LOL();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public Game playGame2() &#123;</span><br><span class="line">      return new WOW();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PVEFactory implements ComputerFactory3&#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public Game playGame() &#123;</span><br><span class="line">      return new DNF();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public Game playGame2() &#123;</span><br><span class="line">      return new WOW();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*抽象工厂*&#x2F;</span><br><span class="line">ComputerFactory3 cf3&#x3D;new PVPFactory();</span><br><span class="line">		cf3.playGame().play();</span><br><span class="line">		cf3.playGame2().play();</span><br><span class="line">		ComputerFactory3 cf4&#x3D;new PVEFactory();</span><br><span class="line">		cf4.playGame().play();</span><br><span class="line">		cf4.playGame2().play();</span><br></pre></td></tr></table></figure>



<h5 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a>优缺点：</h5><p>它的优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了。</p>
<p>而缺点就在于新增新的行为会比较麻烦，因为当添加一个新的产品对象时，需要更加需要更改接口及其下所有子类。</p>
<h2 id="建造者模式："><a href="#建造者模式：" class="headerlink" title="建造者模式："></a>建造者模式：</h2><h5 id="思想：-1"><a href="#思想：-1" class="headerlink" title="思想："></a>思想：</h5><p>用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p>
<p>主要是将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>适用于那些产品对象的内部结构比较复杂。</p>
<h5 id="实现：-3"><a href="#实现：-3" class="headerlink" title="实现："></a>实现：</h5><p>客户只需使用FoodStore类就可以创建出一顿饭，</p>
<p>并根据条件不同，创造出不同的一顿饭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FoodStore foodStore=<span class="keyword">new</span> FoodStore();</span><br><span class="line">Meal meal=foodStore.createBreakfast(<span class="keyword">new</span> Breakfast());</span><br><span class="line">Meal meal2=foodStore.createBreakfast(<span class="keyword">new</span> Lunch());</span><br><span class="line">System.out.println(<span class="string">"小明早上吃的是:"</span>+meal.getFood()+<span class="string">",喝的饮料是:"</span>+meal.getDrinks());</span><br><span class="line">System.out.println(<span class="string">"小明中午吃的是:"</span>+meal2.getFood()+<span class="string">",喝的饮料是:"</span>+meal2.getDrinks());</span><br></pre></td></tr></table></figure>



<h5 id="优缺点：-2"><a href="#优缺点：-2" class="headerlink" title="优缺点："></a>优缺点：</h5><ul>
<li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.cnblogs.com/pony1223/p/7608955.html" target="_blank" rel="noopener">JAVA设计模式总结之23种模式</a></p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">图说设计模式–Graphic Design Pattern</a></p>
<p><a href="https://github.com/xuwujing/java-study" target="_blank" rel="noopener">代码来自</a></p>
]]></content>
      <tags>
        <tag>Java;creation mode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_23种设计模式</title>
    <url>/2020/03/28/Java-23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h1><h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h2><p>设计模式是一套被反复，多人知晓的，经过分类编目的，代码设计的经验总结。</p>
<p>使用设计模式是为了代码重用性，代码可靠性。</p>
<p>设计模式是软件工程的基石。</p>
<p>针对某类问题的某种通用解决方法。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</p>
<p>结构型模式：把类或对象结合在一起形成一个更大的结构。</p>
<p>行为型模式：类和对象如何交互，及划分责任和算法。</p>
<p>如下图所示：</p>
<p><img src="/2020/03/28/Java-23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2020-03-28-a.png" alt></p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a><a href="https://yhang-tech.github.io/2020/04/01/Java-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">创建型模式</a></h2>]]></content>
      <tags>
        <tag>Java;design_pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射机制</title>
    <url>/2020/03/21/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="一、反射是什么"><a href="#一、反射是什么" class="headerlink" title="一、反射是什么"></a>一、反射是什么</h2><p>反射技术可以对一个类进行解剖。</p>
<p>反射是Java特征之一，是一种间接操作目标对象的机制。</p>
<p>机制：运行时动态加载，可获取任意一个类的所有属性和方法，调用方法，访问属性。程序中对象的类型一般都是在编译期就确定下来的，而当我们的程序在运行时，可能需要动态的加载一些类，这些类因为之前用不到，所以没有加载到jvm，这时，使用Java反射机制可以在运行期动态的创建对象并调用其属性，它是在运行时根据需要才加载。</p>
<p>特性：动态</p>
<h2 id="二、反射原理"><a href="#二、反射原理" class="headerlink" title="二、反射原理"></a>二、反射原理</h2><p>Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p>
<p>Class 对象是在反射中会使用到的一类系统定义的类实例。</p>
<p><img src="/2020/03/21/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/2020-03-22-a.png" alt></p>
<p>上图中，Student 类产生了两个实例，但只会有一个Student类 对应的Class 对象。</p>
<p>而Teacher 类有一个Teacher类对应的Class 对象。</p>
<h2 id="三、反射用途"><a href="#三、反射用途" class="headerlink" title="三、反射用途"></a>三、反射用途</h2><p>1、反编译：.class–&gt;.java</p>
<p>2、通过反射机制访问java对象的属性，方法，构造方法等</p>
<p>3、当我们在使用IDE,比如Ecplise时，<u>当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射</u>。</p>
<p>4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。</p>
<h2 id="四、使用反射需import"><a href="#四、使用反射需import" class="headerlink" title="四、使用反射需import"></a>四、使用反射需import</h2><p>Java.lang.Class;</p>
<p>Java.lang.reflect.Constructor;</p>
<p>Java.lang.reflect.Field;</p>
<p>Java.lang.reflect.Method;</p>
<p>Java.lang.reflect.Modifier;</p>
<h2 id="五、反射的基本使用："><a href="#五、反射的基本使用：" class="headerlink" title="五、反射的基本使用："></a>五、反射的基本使用：</h2><h4 id="1、获得Class：主要有三种方法："><a href="#1、获得Class：主要有三种方法：" class="headerlink" title="1、获得Class：主要有三种方法："></a><strong>1、获得Class：主要有三种方法：</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fanshe</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//第一种方式获取Class对象  </span></span><br><span class="line">		Student stu1 = <span class="keyword">new</span> Student();<span class="comment">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class="line">		Class stuClass = stu1.getClass();<span class="comment">//（1）Object--&gt;getClass，获取Class对象</span></span><br><span class="line">		System.out.println(stuClass.getName());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第二种方式获取Class对象</span></span><br><span class="line">		Class stuClass2 = Student<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//（2）任何数据类型（包括基本的数据类型）都有一个“静态”的class属性</span></span><br><span class="line">		System.out.println(stuClass == stuClass2);<span class="comment">//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第三种方式获取Class对象</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class stuClass3 = Class.forName(<span class="string">"fanshe.Student"</span>);<span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line">            <span class="comment">//（3）通过class类的静态方法：forName(String className)（最常用）</span></span><br><span class="line">			System.out.println(stuClass3 == stuClass2);<span class="comment">//判断三种方式是否获取的是同一个Class对象</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在运行期间，一个类，只有一个Class对象产生，所以打印结果都是true；</p>
<p>三种方式中，常用第三种，第一种对象都有了还要反射干什么，第二种需要导入类包，依赖太强，不导包就抛编译错误。一般都使用第三种，一个字符串可以传入也可以写在配置文件中等多种方法。</p>
<h4 id="2、判断是否为某个类的示例："><a href="#2、判断是否为某个类的示例：" class="headerlink" title="2、判断是否为某个类的示例："></a><strong>2、判断是否为某个类的示例：</strong></h4><p>一般的，我们使用instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断时候为某个类的实例，他是一个native方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3、创建实例：通过反射来生成对象主要有两种方法："><a href="#3、创建实例：通过反射来生成对象主要有两种方法：" class="headerlink" title="3、创建实例：通过反射来生成对象主要有两种方法："></a><strong>3、创建实例：通过反射来生成对象主要有两种方法：</strong></h4><p>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; c = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure>

<p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，<u>这种方法可以用指定的构造器构造类的实例。</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取String的Class对象</span></span><br><span class="line">Class&lt;?&gt; str = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//通过Class对象获取指定的Constructor构造器对象</span></span><br><span class="line">Constructor constructor=c.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//根据构造器创建实例：</span></span><br><span class="line">Object obj = constructor.newInstance(“hello reflection”);</span><br></pre></td></tr></table></figure>

<h4 id="4-获取构造方法、成员变量、成员函数并调用："><a href="#4-获取构造方法、成员变量、成员函数并调用：" class="headerlink" title="4.获取构造方法、成员变量、成员函数并调用："></a>4.获取构造方法、成员变量、成员函数并调用：</h4><h5 id="1-批量获取所得的“公有的”方法："><a href="#1-批量获取所得的“公有的”方法：" class="headerlink" title="1.批量获取所得的“公有的”方法："></a>1.批量获取所得的“公有的”方法：</h5><p>public Constructor[] getConstructors()</p>
<p>public Field[] getFields()</p>
<p>public Method[] getMethods()</p>
<h5 id="2-批量获得所得的方法（包括：私有、受保护、默认、公有）"><a href="#2-批量获得所得的方法（包括：私有、受保护、默认、公有）" class="headerlink" title="2.批量获得所得的方法（包括：私有、受保护、默认、公有）"></a>2.批量获得所得的方法（包括：私有、受保护、默认、公有）</h5><p>public Constructor[] getDeclaredConstructors()</p>
<p>public Field[] getDeclaredFields()</p>
<p>public Method[] getDeclaredMethods()</p>
<h5 id="3-获取单个“公有的”方法"><a href="#3-获取单个“公有的”方法" class="headerlink" title="3.获取单个“公有的”方法"></a>3.获取单个“公有的”方法</h5><p>public Constructor getConstructor(Class… parameterTypes)：括号内为类型（class对象），如：char.class,null</p>
<p>public Field getField(String fieldName)：括号内为属性名称</p>
<p>public Method getMethod(String name,Class&lt;?&gt;… parameterTypes)：括号内为方法名，形参的类型（class对象）</p>
<h5 id="4-获取所有单个方法（包括私有的，不包括继承的"><a href="#4-获取所有单个方法（包括私有的，不包括继承的" class="headerlink" title="4.获取所有单个方法（包括私有的，不包括继承的)"></a>4.获取所有单个方法（包括私有的，不包括继承的)</h5><p>public Constructor getDeclaredConstructor(Class… parameterTypes)</p>
<p>public Field getDeclaredField(String fieldName)</p>
<p>public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes) </p>
<h5 id="5-调用"><a href="#5-调用" class="headerlink" title="5.调用"></a>5.调用</h5><p>Constructor–&gt;newInstance(Object… initargs) 参数为：构造方法对应的参数</p>
<p>Field –&gt; public void set(Object obj,Object value) 参数为：要设置的字段所在的对象；要为字段设置的值</p>
<p>Method –&gt; public Object invoke(Object obj,Object… args) 参数为：要调用方法的对象；调用方式时所传递的实参</p>
<h5 id="6、反射main方法"><a href="#6、反射main方法" class="headerlink" title="6、反射main方法"></a>6、反射main方法</h5><p><strong>7、利用发射创建数值</strong></p>
<h5 id="8-反射方法的其他使用–通过反射运行配置文件内容"><a href="#8-反射方法的其他使用–通过反射运行配置文件内容" class="headerlink" title="8.反射方法的其他使用–通过反射运行配置文件内容"></a>8.反射方法的其他使用–通过反射运行配置文件内容</h5><p><strong>9、反射方法的其他使用–通过反射越过泛型检查</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">https://blog.csdn.net/sinat_38259539/article/details/71799078</a></p>
<p><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">https://www.sczyh30.com/posts/Java/java-reflection-1/</a></p>
<p><a href="https://blog.csdn.net/liujiahan629629/article/details/18013523" target="_blank" rel="noopener">https://blog.csdn.net/liujiahan629629/article/details/18013523</a></p>
<p>直接摘录自：<a href="https://blog.csdn.net/a745233700/article/details/82893076" target="_blank" rel="noopener">https://blog.csdn.net/a745233700/article/details/82893076</a></p>
]]></content>
      <tags>
        <tag>reflect;Java;basic</tag>
      </tags>
  </entry>
  <entry>
    <title>java注解</title>
    <url>/2020/03/18/java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="注解Annotation-用法-："><a href="#注解Annotation-用法-：" class="headerlink" title="注解Annotation 用法 ："></a>注解Annotation 用法 ：</h2><p>注解又称Java 标注，是一种注释机制</p>
<p>java中，类、方法、变量、参数、包都可以被标注，java可以通过反射获得标注内容。</p>
<p>java 可以在运行时获得标注内容</p>
<p>Java自定义了7个注解</p>
<p>在代码中作用的注解：</p>
<p>@Override 检查该方法是否被重写，在父类或接口中未发现该方法，编译报错</p>
<p>@Deprecated 标记过时方法，若使用该方法，编译报错</p>
<p>@SuppressWarnings 指示编译器去忽略注解中声明的警告</p>
<p>作用在其他注解中的注解（元注解）：</p>
<p>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</p>
<p>@Documented - 标记这些注解是否包含在用户文档中。</p>
<p>@Target - 标记这个注解应该是哪种 Java 成员。</p>
<p>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</p>
<h3 id="Annotation-通用定义"><a href="#Annotation-通用定义" class="headerlink" title="Annotation 通用定义"></a>Annotation 通用定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。定义了 MyAnnotation1 之后，我们可以在代码中通过 “@MyAnnotation1” 来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。下面分别说说它们的含义：</p>
<p><strong>(01) @interface</strong></p>
<p>使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。</p>
<p>定义 Annotation 时，@interface 是必须的。</p>
<p>注意：它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。</p>
<p><strong>(02) @Documented</strong></p>
<p>类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。</p>
<p>定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。</p>
<p><strong>(03) @Target(ElementType.TYPE)</strong></p>
<p>前面我们说过，ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。</p>
<p>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p>
<p>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。</p>
<p><strong>(04) @Retention(RetentionPolicy.RUNTIME)</strong></p>
<p>前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。</p>
<p>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。</p>
<p>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</p>
<h3 id="常用注解-Deprecated"><a href="#常用注解-Deprecated" class="headerlink" title="常用注解 @Deprecated"></a>常用注解 @Deprecated</h3><p>@Deprecated 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>(01) @interface – 它的用来修饰 Deprecated，意味着 Deprecated 实现了 java.lang.annotation.Annotation 接口；即 Deprecated 就是一个注解。 </p>
<p>(02) @Documented – 它的作用是说明该注解能出现在 javadoc 中。</p>
<p>(03) @Retention(RetentionPolicy.RUNTIME) – 它的作用是指定 Deprecated 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将Deprecated 的信息保留在 .class 文件中，并且能被虚拟机读取。</p>
<p>(04) @Deprecated 所标注内容，不再被建议使用。</p>
<p>例如，若某个方法被 @Deprecated 标注，则该方法不再被建议使用。如果有开发人员试图使用或重写被 @Deprecated 标示的方法，编译器会给相应的提示信息。示例如下:</p>
<p><img src="/2020/03/18/java%E6%B3%A8%E8%A7%A3/2020-03-18-a.jpg" alt></p>
<h3 id="常用注解Inherited"><a href="#常用注解Inherited" class="headerlink" title="常用注解Inherited"></a><strong>常用注解Inherited</strong></h3><p>@Inherited 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>(01) @interface – 它的用来修饰 Inherited，意味着 Inherited 实现了 java.lang.annotation.Annotation 接口；即 Inherited 就是一个注解。</li>
<li>(02) @Documented – 它的作用是说明该注解能出现在 javadoc 中。</li>
<li>(03) @Retention(RetentionPolicy.RUNTIME) – 它的作用是指定 Inherited 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将 Inherited 的信息保留在 .class 文件中，并且能被虚拟机读取。</li>
<li>(04) @Target(ElementType.ANNOTATION_TYPE) – 它的作用是指定 Inherited 的类型是 ANNOTATION_TYPE。这就意味着，@Inherited 只能被用来标注 “Annotation 类型”。</li>
<li>(05) @Inherited 的含义是，它所标注的Annotation将具有继承性。</li>
</ul>
<p>假设，我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了</p>
<p>MyAnnotation，则 Base 具有了”具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。</p>
<p>@Inherited 的使用示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## InheritableSon.java</span><br><span class="line"></span><br><span class="line">**<span class="keyword">import</span>** java.lang.annotation.Target;</span><br><span class="line">**<span class="keyword">import</span>** java.lang.annotation.ElementType;</span><br><span class="line">**<span class="keyword">import</span>** java.lang.annotation.Retention;</span><br><span class="line">**<span class="keyword">import</span>** java.lang.annotation.RetentionPolicy;</span><br><span class="line">**<span class="keyword">import</span>** java.lang.annotation.Inherited;</span><br><span class="line"></span><br><span class="line">**/\**</span><br><span class="line"> \* 自定义的Annotation。</span><br><span class="line"> \*<span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@Target</span>(ElementType.TYPE)</span></span><br><span class="line"><span class="comment"><span class="doctag">@Retention</span>(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment"><span class="doctag">@Inherited</span></span></span><br><span class="line"><span class="comment">@**interface** Inheritable</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@Inheritable</span></span></span><br><span class="line"><span class="comment">**class** InheritableFather</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  **public** InheritableFather() &#123;</span></span><br><span class="line"><span class="comment">    */</span>/ InheritableBase是否具有 Inheritable Annotation*</span><br><span class="line">    System.out.println(<span class="string">"InheritableFather:"</span>+InheritableFather.**<span class="class"><span class="keyword">class</span>**.<span class="title">isAnnotationPresent</span>(<span class="title">Inheritable</span>.**<span class="title">class</span>**))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**/\**</span><br><span class="line"> \* InheritableSon 类只是继承于 InheritableFather，</span><br><span class="line"> \*<span class="comment">/**</span></span><br><span class="line"><span class="comment">**public** **class** InheritableSon **extends** InheritableFather</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  **public** InheritableSon() &#123;</span></span><br><span class="line"><span class="comment">    **super**();   */</span>/ 调用父类的构造函数*</span><br><span class="line">    *<span class="comment">// InheritableSon类是否具有 Inheritable Annotation*</span></span><br><span class="line">    System.out.println(<span class="string">"InheritableSon:"</span>+InheritableSon.**<span class="class"><span class="keyword">class</span>**.<span class="title">isAnnotationPresent</span>(<span class="title">Inheritable</span>.**<span class="title">class</span>**))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  **<span class="keyword">public</span>** **<span class="keyword">static</span>** **<span class="keyword">void</span>** main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line">    InheritableSon is = **<span class="keyword">new</span>** InheritableSon();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InheritableFather:true</span><br><span class="line">InheritableSon:true</span><br></pre></td></tr></table></figure>

<p>现在，我们对 InheritableSon.java 进行修改：注释掉 “Inheritable 的 @Inherited 注解”。</p>
<h2 id="InheritableSon-java"><a href="#InheritableSon-java" class="headerlink" title="InheritableSon.java"></a>InheritableSon.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>** java.lang.annotation.Target;</span><br><span class="line">**<span class="keyword">import</span>** java.lang.annotation.ElementType;</span><br><span class="line">**<span class="keyword">import</span>** java.lang.annotation.Retention;</span><br><span class="line">**<span class="keyword">import</span>** java.lang.annotation.RetentionPolicy;</span><br><span class="line">**<span class="keyword">import</span>** java.lang.annotation.Inherited;</span><br><span class="line"></span><br><span class="line">**/\**</span><br><span class="line"> \* 自定义的Annotation。</span><br><span class="line"> \*<span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@Target</span>(ElementType.TYPE)</span></span><br><span class="line"><span class="comment"><span class="doctag">@Retention</span>(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">*/</span>/<span class="meta">@Inherited</span>*</span><br><span class="line">@**<span class="class"><span class="keyword">interface</span>** <span class="title">Inheritable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inheritable</span></span><br><span class="line">**<span class="class"><span class="keyword">class</span>** <span class="title">InheritableFather</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  **<span class="keyword">public</span>** InheritableFather() &#123;</span><br><span class="line">    *<span class="comment">// InheritableBase是否具有 Inheritable Annotation*</span></span><br><span class="line">    System.out.println(<span class="string">"InheritableFather:"</span>+InheritableFather.**<span class="class"><span class="keyword">class</span>**.<span class="title">isAnnotationPresent</span>(<span class="title">Inheritable</span>.**<span class="title">class</span>**))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**/\**</span><br><span class="line"> \* InheritableSon 类只是继承于 InheritableFather，</span><br><span class="line"> \*<span class="comment">/**</span></span><br><span class="line"><span class="comment">**public** **class** InheritableSon **extends** InheritableFather</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  **public** InheritableSon() &#123;</span></span><br><span class="line"><span class="comment">    **super**();   */</span>/ 调用父类的构造函数*</span><br><span class="line">    *<span class="comment">// InheritableSon类是否具有 Inheritable Annotation*</span></span><br><span class="line">    System.out.println(<span class="string">"InheritableSon:"</span>+InheritableSon.**<span class="class"><span class="keyword">class</span>**.<span class="title">isAnnotationPresent</span>(<span class="title">Inheritable</span>.**<span class="title">class</span>**))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  **<span class="keyword">public</span>** **<span class="keyword">static</span>** **<span class="keyword">void</span>** main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line">    InheritableSon is = **<span class="keyword">new</span>** InheritableSon();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InheritableFather:true</span><br><span class="line">InheritableSon:false</span><br></pre></td></tr></table></figure>

<h4 id="对比上面的两个结果，我们发现：当注解-Inheritable-被-Inherited-标注时，它具有继承性。否则，没有继承性。"><a href="#对比上面的两个结果，我们发现：当注解-Inheritable-被-Inherited-标注时，它具有继承性。否则，没有继承性。" class="headerlink" title="对比上面的两个结果，我们发现：当注解 Inheritable 被 @Inherited 标注时，它具有继承性。否则，没有继承性。"></a>对比上面的两个结果，我们发现：当<u>注解 Inheritable 被 @Inherited 标注</u>时，它具有继承性。否则，没有继承性。</h4><h2 id="Annotation-的作用"><a href="#Annotation-的作用" class="headerlink" title="Annotation 的作用"></a>Annotation 的作用</h2><p>Annotation 是一个辅助类，它在 Junit、Struts、Spring 等工具框架中被广泛使用。</p>
<p>我们在编程中经常会使用到的 Annotation 作用有：</p>
<h3 id="1）编译检查"><a href="#1）编译检查" class="headerlink" title="1）编译检查"></a>1）编译检查</h3><p>Annotation 具有”让编译器进行编译检查的作用”。</p>
<h3 id="2-在反射中使用-Annotation"><a href="#2-在反射中使用-Annotation" class="headerlink" title="2) 在反射中使用 Annotation"></a>2) 在反射中使用 Annotation</h3><h3 id="3-根据-Annotation-生成帮助文档"><a href="#3-根据-Annotation-生成帮助文档" class="headerlink" title="3) 根据 Annotation 生成帮助文档"></a>3) 根据 Annotation 生成帮助文档</h3><p>通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。</p>
<h3 id="4-能够帮忙查看查看代码"><a href="#4-能够帮忙查看查看代码" class="headerlink" title="4) 能够帮忙查看查看代码"></a>4) 能够帮忙查看查看代码</h3><p>通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。</p>
<p>另外，我们也可以通过自定义 Annotation 来实现一些功能。</p>
<p>参考资料：</p>
<blockquote>
<p>原文地址：<a href="https://www.cnblogs.com/skywang12345/p/3344137.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3344137.html</a></p>
<p>摘录自：<a href="https://www.runoob.com/w3cnote/java-annotation.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/java-annotation.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Java;Basic；Annotation；</tag>
      </tags>
  </entry>
  <entry>
    <title>postgreSQL:SHA-256算法分析</title>
    <url>/2020/03/10/postgreSQL-SHA-256/</url>
    <content><![CDATA[<p>由于数据库系统实现课程要求,对postgreSQL数据库进行了部分分析。</p>
<p>我负责的部分是SHA-256安全认证机制的分析，所以今天把分析成果稍稍展示一下。SHA-256是一个哈希函数，负责将传递的消息进行加密，得到256-bit的加密过的消息摘要。所以下面会介绍如何通过SHA-256将一条信息逐步加密：</p>
<h2 id="SHA-256算法实现"><a href="#SHA-256算法实现" class="headerlink" title="SHA-256算法实现"></a>SHA-256算法实现</h2><h3 id="前置条件："><a href="#前置条件：" class="headerlink" title="前置条件："></a>前置条件：</h3><ul>
<li>32-bit 是SHA-256的最小基本处理单元。</li>
<li>SHA-256规定8个哈希值和64个哈希常量，皆为32-bit。</li>
<li>消息预处理，将消息附加填充位（100……000）和附加长度信息，使其</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">消息原本长度+附加填充位长度（长度随随情况而定）+64（长度信息的位数）&#x3D;&#x3D;512的整数倍</span><br></pre></td></tr></table></figure>



<h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><ol>
<li><p>将消息分成n个512-bit大小的块</p>
<p><img src="/2020/03/10/postgreSQL-SHA-256/2020-03-09-a.png" alt="分解图"></p>
</li>
<li><p>将每个块分解成基本单元word，可以直接分成16个word，再通过这16个word 构造出其余48个word，这一步共得出64个word ，w[0]…w[63] </p>
</li>
<li><p>进行n次迭代，n是消息分成的块数。消息摘要的初始值是8个哈希值</p>
</li>
</ol>
<img src="/2020/03/10/postgreSQL-SHA-256/2020-03-09-c.png" alt="初始值" style="zoom:60%;">

<p>每一次迭代中，通过旧消息摘要和Mi由映射函数将其计算得到新消息摘要，再将新消息摘要作为下一次迭代的一个输入，重复n次。</p>
<img src="/2020/03/10/postgreSQL-SHA-256/2020-03-09-b.png" alt="迭代图" style="zoom:60%;">



<h2 id="映射函数："><a href="#映射函数：" class="headerlink" title="映射函数："></a>映射函数：</h2><p><img src="/2020/03/10/postgreSQL-SHA-256/2020-03-09-d.png" alt="映射函数"></p>
<p>映射关系是每次迭代过程中会进行的数值计算。</p>
<p>上图中，每次计算新消息摘要会进行64次循环计算；蓝色方框代表固定逻辑函数；红色方框代表取余运算，使结果不超过2^32。</p>
<p>每次计算的输入：</p>
<ul>
<li>旧消息摘要（初始摘要或者上次计算结果）</li>
<li>Wt 每一个块消息分解产生的64个word，依次序加入计算</li>
<li>Kt 64个哈希常量，依次加入计算</li>
</ul>
<p>计算的输出：</p>
<ul>
<li>一个新的最小单元32-bit的数据，即word[A]</li>
</ul>
<p>计算结果：由word[A]开头，其余7个word 由旧消息摘要右移32-bit组成的消息摘要。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SHA是一个多重计算过程的算法，理解起来不难：大循环套小循环计算。</p>
<p>计算量不知道；现行破解可能性不知道。</p>
<p>参考资料：<a href="https://blog.csdn.net/u011583927/article/details/80905740" target="_blank" rel="noopener">CSDN-随煜而安</a></p>
]]></content>
      <tags>
        <tag>database;SHA-256;algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>从Halo开始：学习Gradle</title>
    <url>/2020/03/07/%E4%BB%8EHalo%E5%BC%80%E5%A7%8B%EF%BC%9A%E5%AD%A6%E4%B9%A0Gradle/</url>
    <content><![CDATA[<h2 id="Halo"><a href="#Halo" class="headerlink" title="Halo"></a>Halo</h2><p>在GitHub上的一个轻量级开源项目，一款现代化的个人独立博客系统。</p>
<p>非学习用开源项目，但如果能通过自己理解项目构建、源码，对初学者来说，未必不是一个好的选择。</p>
<h2 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h2><p>将程序自动化的构建工具，集编译源代码、运行测试、拷贝Class文件到目标目录、签名、打包、依赖管理等功能于一体。</p>
<p>构建包括编译、连接以及打包。通过Gradle，能做什么？</p>
<ul>
<li>下载依赖</li>
<li>源码编译成二进制代码</li>
<li>打包生成的二进制代码</li>
<li>进行单元测试</li>
<li>部署到生产系统</li>
</ul>
<p>依赖部署如果仅仅依靠手动配置，是很麻烦容易出错，无法成为可行商用化的成果。</p>
<h2 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h2><p>现在没有学习gradle的使用，仅分析Halo项目中build.gradle文件的各行代码的意义。</p>
<p>通过注释+文档的形式来学习。</p>
<p>gradle 采用以下形式来调用构建脚本块:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">脚本块名&#123;</span><br><span class="line">       执行语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细查看官网：<a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">Gradle</a></p>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p><strong>plugins</strong> 中文译意：插件；外挂</p>
<p>DSL，用于声明要在脚本中使用的插件。</p>
<p>使用时，该<code>plugins {}</code>块仅允许使用完整构建脚本编程语言的严格子集。值必须是文字的（例如，常量字符串，而不是变量）。允许插入字符串<code>PluginDependencySpec.version(java.lang.String)</code>，但是替换值必须来自Gradle属性。</p>
<p>此外，该<code>plugins {}</code>块必须是构建脚本的第一个代码。对此有一个例外，因为<code>buildscript {</code>}块（用于声明脚本依赖项）必须位于它之前。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><em>使用方法</em></h3><h4 id="PluginDependencySpec-id-String-id"><a href="#PluginDependencySpec-id-String-id" class="headerlink" title="PluginDependencySpec id(String id)"></a><code>PluginDependencySpec id(String id)</code></h4><p>在具有给定id的插件上添加依赖项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &quot;org.company.myplugin&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过返回值的方法指定其他约束（例如版本号）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &quot;org.company.myplugin&quot; version &quot;1.3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，插件会自动应用于当前脚本。可以使用以下<code>apply false</code>选项禁用它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &quot;org.company.myplugin&quot; version &quot;1.3&quot; apply false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用的插件"><a href="#使用的插件" class="headerlink" title="使用的插件"></a>使用的插件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot</span><br></pre></td></tr></table></figure>

<p>需要使用SpringBoot 而插入的插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io.freefair.lombok</span><br></pre></td></tr></table></figure>

<p>自动lombok和delombok配置的插件</p>
<p>lombok 是Java库，Lombok提供了一组有用的注解，通过“<strong><em>@注解名</em></strong> ”的方法实现。</p>
<p>如：@Setter ：注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。</p>
<p>@Getter ：使用方法同上，区别在于生成的是getter方法。</p>
<p>@ToString ：注解在类，添加toString方法。</p>
<p>@EqualsAndHashCode： 注解在类，生成hashCode和equals方法。</p>
<p>@NoArgsConstructor： 注解在类，生成无参的构造方法。</p>
<p>@RequiredArgsConstructor： 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。</p>
<p>@AllArgsConstructor： 注解在类，生成包含类中所有字段的构造方法。</p>
<p>@Data： 注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkstyle</span><br></pre></td></tr></table></figure>

<p>代码检查;检查源文件编码规范。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io.spring.dependency-management</span><br></pre></td></tr></table></figure>

<p>提供类似Maven的依赖管理功能的Gradle插件。</p>
]]></content>
      <tags>
        <tag>Personal study notes;Unprofessional</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2020/02/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>通过bilibili上观看codesheep 的视频，成功搭建基于 github库上 hexo博客</p>
<p>感谢up主和弹幕大佬们</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>因为确实是技术小白，视频中有很多名词是今天才接触到或者说是去了解它。</p>
<p>首先是hexo：一种blog框架，前置配置是git和node.js</p>
<p>其次是git和node.js：git – 开源的分布式版本控制系统 ，所以这里需要我去多多了解git及github的工作。node.js– Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 </p>
<p>然后是markdown格式及其编辑与工具typora:<br>markdown是一种实用的纯文本标记语言，通过typora可以在展示格式和源码格式编辑。</p>
<p>最后是重新唤起了命令行的操作方式的记忆，命令行是程序员经常会使用的工具，小白还是多使用为妙。</p>
<p>定下一个小目标，学习Java及上手开源实践项目，为以后的发展奠定基础。</p>
<hr>
<h4 id="参考文件：程序羊"><a href="#参考文件：程序羊" class="headerlink" title="参考文件：程序羊"></a>参考文件：<a href="www.codesheep.cn">程序羊</a></h4>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
